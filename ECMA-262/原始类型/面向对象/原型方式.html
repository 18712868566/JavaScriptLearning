<!DOCTYPE HTML>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		<style type="text/css">
			ul,li{
				list-style-type: none;
			}
			#content{width:960px;margin:0 auto;}
			i{color:red;}
		</style>
	</head>
	<body>
	<div id="content">
		<h1>原型方法</h1>
		<p>
			该方式利用了对象的 prototype 属性，可以把它看成创建新对象所依赖的原型。
这里，首先用空构造函数来设置类名。然后所有的属性和方法都被直接赋予 prototype 属性
		</p>
	</div>
	</body>
	<script>
		//原始的方法
		/*它的颜色是红色，有四个门，每加仑油可以跑 25 英里。
		var oCar = new Object;
		oCar.color = "red";
		oCar.doors = 4;
		oCar.mpg = 25;
		oCar.showColor = function(){
			alert(this.color);
		}
		
		//工厂方法
		function createCar(){
			var oTempCar = new Object;
			oTempCar.color = "blue";
			oTempCar.doors = 4;
			oTempCar.mpg = 25;
			oTempCar.showColor = function(){
				alert(this.color);
			}
			return oTempCar;
		}
		 
		 var oCar1 = createCar();
		 var oCar2 = createCar();
		 
 		 alert(oCar1.color);
		 alert(oCar2.color);
		 
		 
		 //为函数传递参数
		 //给 createCar() 函数加上参数，即可为要创建的 car 对象的 color、doors 和 mpg 属性赋值。这使两个对象具有相同的属性，却有不同的属性值。
		 function createCar(sColor,iDoors,iMpg){
			var oTempCar = new Object;
			oTempCar.color = sColor;
			oTempCar.doors = iDoors;
			oTempCar.mpg = iMpg;
			oTempCar.showColor = function(){
				alert(this.color);
			}
			return oTempCar;
		 }
		 var oCar1 = createCar("red",4,20);
		 var oCar2 = createCar("black",6,25);
		 
		 oCar1.showColor();    //输出red
		 oCar2.showColor();    //输出blue
		 
		 
		 //构造函数模式
		 //创建构造函数就像创建工厂函数一样容易。第一步选择类名，即构造函数的名字。根据惯例，这个名字的首字母大写，以使它与首字母通常是小写的变量名分开。除了这点不同，构造函数看起来很像工厂函数。请考虑下面的例子：
		 
		 function Car(sColor,iDoors,iMpg){    //构造函数名首字母大写
			this.color = sColor;
			this.doors = iDoors;
			this.mpg = iMpg;
			this.showColor = function(){
				alert(this.color);
			};
		 }
		 
		 var oCar1 = new Car("red",4,23);
		 var oCar2 = new Car("blue",6,25);
		 
		 alert(oCar1.mpg);
		 alert(oCar2.mpg);
		 
		 
		 //原型方法
		 
		 function Car(){
			//定义构造函数Car 
		 }
		 
		 Car.prototype.color = "blue";
		 Car.prototype.doors = 4;
		 Car.prototype.mpg = 25;
		 Car.prototype.showColor = function(){
			alert(this.color);
		 }
		 var oCar1 = new Car();
		 var oCar2 = new Car();
		 //还能用 instanceof 运算符检查给定变量指向的对象的类型
		 
		 alert(oCar1 instanceof Car);   // true
		 
		 
		 
		 //原型方法的问题
		 //首先，这个构造函数没有参数。使用原型方式，不能通过给构造函数传递参数来初始化属性的值，因为 Car1 和 Car2 的 color 属性都等于 "blue"，doors 属性都等于 4，mpg 属性都等于 25。这意味着必须在对象创建后才能改变属性的默认值，这点很令人讨厌，但还没完。真正的问题出现在属性指向的是对象，而不是函数时。函数共享不会造成问题，但对象却很少被多个实例共享。请思考下面的例子：
		 
		 function Car(){
			
		 }
		 Car.prototype.color = "blue";
		 Car.prototype.doors = 4;
		 Car.prototype.mpg = 25;
		 Car.prototype.drivers = new Array("Mike","John");
		 Car.prototype.showColor = function(){
			alert(this.color);
		 }
		 
		 var oCar1 = new Car();
		 var oCar2 = new Car();  
		 
		 oCar1.drivers.push("bill");
		 
		 alert(oCar1.drivers);
		 alert(oCar2.drivers);
		 
		 //上面的代码中，属性 drivers 是指向 Array 对象的指针，该数组中包含两个名字 "Mike" 和 "John"。由于 drivers 是引用值，Car 的两个实例都指向同一个数组。这意味着给 oCar1.drivers 添加值 "Bill"，在 oCar2.drivers 中也能看到。输出这两个指针中的任何一个，结果都是显示字符串 "Mike,John,Bill"。
		//由于创建对象时有这么多问题，你一定会想，是否有种合理的创建对象的方法呢？答案是有，需要联合使用构造函数和原型方式。
		*/
		 
		  
		  
		//混合的构造函数/原型方法 
		//联合使用构造函数和原型方式，就可像用其他程序设计语言一样创建对象。这种概念非常简单，即用构造函数定义对象的所有非函数属性，用原型方式定义对象的函数属性（方法）。结果是，所有函数都只创建一次，而每个对象都具有自己的对象属性实例。
		 
		 
		 function Car(sColor,iDoors,iMpg){    //构造
			this.color = sColor;
			this.doors = iDoors;
			this.mpg = iMpg;
			this.drivers = new Array("Mike","John");
		 }		
		 Car.prototype.showColor = function(){   //原型
			alert(this.color);
		 }
		 
		 var oCar1 = new Car("red",5,20);
		 var oCar2 = new Car("blue",4,23);
		 
		 oCar1.drivers.push("bill");
		 
		 alert(oCar1.drivers);	  //输出Mike,John,Bill
		 alert(oCar2.drivers);  //输出Mike,John
	</script>
</html>













